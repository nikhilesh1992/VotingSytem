/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpc.h"
#include "definitions.h"

char **
vote_zero_1_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;
	
	clearList();
	clearCandidates();
	if(headV==NULL && tailV==NULL && headC==NULL && tailC==NULL)
		result = "TRUE";
	else	
		result = "FALSE";
	return &result;
}

char **
add_voter_1_svc(intpair *argp, struct svc_req *rqstp)
{
	static char * result;
	
	int VoterId = argp->voterID;
	voterNode* Voter = searchVoter(VoterId);
	if( Voter != NULL )
	{
		result = "EXISTS";
	}
	else if( Voter == NULL)
	{
		addVoter(VoterId);
		result = "OK";
	}
	else
		result = "ERROR";
			
	return &result;
}

char **
vote_1_svc(intpair *argp, struct svc_req *rqstp)
{
	static char * result;

	int VoterId = argp->voterID;
	char tempCandidate[12];
	strcpy(tempCandidate,argp->candidateName);
	voterNode* Voter = searchVoter(VoterId);
	if( Voter == NULL )
	{
		result = "NOTAVOTER";
	}
	else if( Voter != NULL)
	{
		if((Voter->hasVoted)==1)
			result = "ALREADYVOTED";
		else
		{
			if((searchCandidate(tempCandidate))==1)
			{
				voteForCandidate(tempCandidate);
				Voter->hasVoted = 1;
				result = "EXISTS";
			}
			else if((searchCandidate(tempCandidate))==0)
			{
				addCandidate(tempCandidate);
				voteForCandidate(tempCandidate);
				Voter->hasVoted = 1;
				result = "NEW";
			}
			else
				result = "ERROR";
		}	
	}
	else
		result = "ERROR";

	return &result;
}

char **
list_1_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;
	strcpy(bufSend,"");
	
	strcpy(bufSend,listOfCandidates(bufSend));
	if( strcmp(bufSend,"")==0)
		result = "NONE";
	else
		result = bufSend;

	return &result;
}

char **
vote_count_1_svc(intpair *argp, struct svc_req *rqstp)
{
	static char * result;

	char tempCandidate[12];
	strcpy(tempCandidate,argp->candidateName);
	if(searchCandidate(tempCandidate))
	{
		int votes = voteCount(tempCandidate);
		sprintf(voteCounts, "%d", votes);
		result = voteCounts;
	}
	else
	{
		result = "-1";
	}

	return &result;
}

int isEmpty()
{
	if( head==NULL && tail==NULL )
		return 1;
	else
		return 0;
}

void enqueue(char *buffer)
{
	queueNode *addNode=NULL;
	addNode = (queueNode *)malloc(1*sizeof(queueNode));
	stpcpy(addNode -> buf,buffer);
	addNode -> next = NULL;
	if( head==NULL && tail==NULL )
	{
		head = addNode;
		tail = addNode;
	}
	else
	{
		tail -> next = addNode;
		tail = addNode;
	}
}

char * dequeue()
{
	queueNode *temp;
	char *buffer;
	if( head==NULL && tail==NULL )
	{
		printf("No client requesting pending in the queue\n");
		return NULL;
	}
	else
	{
		if( head == tail )
		{
			temp = head;
			stpcpy(buffer,temp -> buf);
			head = NULL;
			tail = NULL;
			temp -> next = NULL;
			free(temp);
			return buffer;
		}
		temp = head;
		stpcpy(buffer,temp -> buf);
		temp = temp -> next;
		free(head);
		head = temp;
		return buffer;
	}
}

int isListEmpty()
{
	if(headV == NULL && tailV == NULL)
		return 1;
	else
		return 0;
}

void addVoter(int Id)
{
	voterNode *addNode;
	addNode = (voterNode *)malloc(1*sizeof(voterNode));
	addNode -> voterId = Id;
	addNode -> hasVoted = 0;
	addNode -> next = NULL;
	if( headV == NULL && tailV == NULL)
	{
		headV = addNode;
		tailV = addNode;
	}
	else
	{
		tailV -> next = addNode;
		tailV = addNode;
	}
}

// If voter exists in the list it returns the complete node or else NULL
voterNode* searchVoter(int id)
{
	voterNode *temp;
	temp = headV;
	while(temp != NULL )
	{
		if( temp -> voterId == id )
		{
			return temp;
		}
		temp = temp -> next;
	}
return NULL;
}

// If a given voter has already voted then returns 1 or else 0	
int hasVotedOrNot(int id)
{
	voterNode *temp;
	temp = headV;
	while(temp != NULL )
	{
		if( temp -> voterId == id && temp -> hasVoted == 1 )
		{
			return 1;
		}
		temp = temp -> next;
	}
return 0;
}

//Clears the complete list of voters
void clearList()
{
	voterNode *temp;
	temp = headV;
	if( headV!=NULL && tailV!=NULL)
	{
		while ( temp -> next != NULL )
		{
			temp = headV;
			temp = temp -> next;
			free(headV);
			headV = temp;
		}
		free(temp);
		headV = NULL;
		tailV = NULL;
	}
}

void addCandidate(char *bufC)
{
	candidateNode *addNode;
	addNode = (candidateNode *)malloc(1*sizeof(candidateNode));
	strcpy(addNode->candidateName,bufC);
	addNode -> numVotes = 0;
	addNode -> next = NULL;
	if( headC == NULL && tailC == NULL)
	{
		headC = addNode;
		tailC = addNode;
	}
	else
	{
		tailC -> next = addNode;
		tailC = addNode;
	}
}

// If candidate already exists in the list it returns 1 or else returns 0
int searchCandidate(char *bufC)
{
	candidateNode *temp;
	temp = headC;
	while(temp != NULL )
	{
		if( strcmp(temp->candidateName,bufC) == 0)
		{
			return 1;
		}
		temp = temp -> next;
	}
return 0;
}

//Increments the vote count for a specified candidate based on it name
void voteForCandidate(char *bufC)
{
	candidateNode *temp;
	temp = headC;
	while(temp != NULL )
	{
		if( strcmp(temp->candidateName,bufC) == 0)
		{
			(temp -> numVotes)++;
			break;
		}
		temp = temp -> next;
	}
} 

//Gives the vote count for a given candidate name
int voteCount(char *bufC)
{
	candidateNode *temp;
	temp = headC;
	while(temp != NULL )
	{
		if( strcmp(temp->candidateName,bufC) == 0)
		{
			return (temp->numVotes);
		}
		temp = temp -> next;
	}
return -1;
} 

//Returns a list of candidates with non-zero votes
char* listOfCandidates(char *bufC)
{
	candidateNode *temp;
	temp = headC;
	int flag=0;
	while(temp != NULL )
	{
		if((flag==0) && (temp->numVotes > 0))
		{
			strcpy(bufC,temp->candidateName);
			//strcat(bufC,",");
			flag = 1;
		}
		else if((flag==1) && (temp->numVotes > 0))
		{
			strcat(bufC,",");
			strcat(bufC,temp->candidateName);
		}

		temp = temp -> next;
	}
	return bufC;
}

//Clears the complete list of candidates
void clearCandidates()
{
	candidateNode *temp;
	temp = headC;
	if( headC!=NULL && tailC!=NULL)
	{
		while ( temp -> next != NULL )
		{
			temp = headC;
			temp = temp -> next;
			free(headC);
			headC = temp;
		}
		free(temp);
		headC = NULL;
		tailC = NULL;
	}
}
